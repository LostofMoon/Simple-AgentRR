## 验证工作流完整分析
以下是当前框架中完整的验证工作流：

###  **框架架构概览**

这是一个**基于DAG（有向无环图）的移动应用任务验证框架**，专门用于验证LLM智能体在移动端执行复杂任务的完成情况。

###  **核心组件与职责**

#### 1. **数据层** (types.py)

- **Frame**: 表示执行轨迹中的一个时间帧，包含截图、XML、推理、动作等信息
- **TaskSpec**: 任务配置规范，定义节点、依赖关系和成功条件
- **VerifierOptions**: 验证选项，配置OCR、LLM等能力
- **VerifyResult**: 验证结果，包含成功状态、匹配路径、人工复核标记等

#### 2. **任务加载层** (loader.py + trace_loader.py)

- **任务配置加载**: 从YAML/JSON文件加载任务DAG定义
- **轨迹数据加载**: 从目录结构提取多模态数据（图片+XML+动作+推理）
- **数据增强**: 自动组装文本字段，添加邻接上下文引用

#### 3. **条件检查层** (conditions.py)

- **基础检查器**: `text_match`、`regex_match`、`ui_flag`、`xml_text_match`、`action_match`
- **高级检查器**: 
  - `escalate`: 多策略升级验证（text→regex→ui→xml→ocr→llm）
  - `dynamic_match`: 动态条件匹配，从任务描述提取条件并验证操作
- **注册机制**: 支持自定义检查器扩展

#### 4. **DAG计算层** (dag.py)

- **依赖关系管理**: 构建节点间的父子关系图
- **拓扑排序**: 确保依赖顺序的正确性
- **环检测**: 验证DAG的有效性

#### 5. **核心验证层** (verifier.py)

verifier:

    - 若节点声明了 deps，则仍按 AND 语义（取所有依赖的最晚命中帧作为起点）
    - 若未声明 deps 且存在 next 来源的父节点，则按 OR 语义（任一父可行即可，取最早完成的父节点作为起点） 回溯时记录选择的父节点，恢复具体路径


- **候选帧收集**: 为每个节点收集满足条件的帧索引
- **动态规划算法**: 基于依赖约束计算每个节点的最小可行索引
- **路径回溯**: 构建最优满足路径
- **帧使用优化**: 支持帧独占和防回退机制

#### 6. **多模态处理层** (ocr_processor.py)

- **OCR文字识别**: 集成app_trajectory_analyzer的OCR引擎
- **智能文本处理**: 多格式文本预处理和匹配策略
- **XML文本提取**: 从Android UI XML中提取所有可见文本
- **降级策略**: OCR失败时自动降级到XML文本提取

###  **验证工作流详细流程**

#### **阶段1: 数据预处理**

```python
# 1. 加载任务配置
task = load_task("task.yaml")  # 解析DAG节点和依赖关系

# 2. 加载执行轨迹  
frames = load_frames_from_dir("trace_folder/")  # 提取图片、XML、动作、推理数据

# 3. 数据增强
# - 为每帧添加索引和上下文引用
# - 组装综合文本字段
# - 提取UI元信息（包名等）
```

#### **阶段2: DAG依赖分析**

```python
# 1. 构建DAG图
dag = DAG(task.nodes)  # 建立节点依赖关系

# 2. 拓扑排序
topo_order = dag.topo_order()  # 确定验证顺序

# 3. 环检测
dag._assert_acyclic()  # 确保DAG有效性
```

#### **阶段3: 帧匹配与候选收集**

```python
def _collect_candidates(frames, task, options):
    cand = {}
    used_frames = set()  # 已使用帧集合
    
    for node in task.nodes:
        hits = []
        checker = get_checker(node.condition.type)
        
        # 帧独占优化：避免OCR/LLM重复使用同一帧
        for i, frame in enumerate(frames):
            if needs_exclusive_access(node) and i in used_frames:
                continue
                
            # 多策略验证
            if checker.check(frame, params, options):
                hits.append(i)
                if needs_exclusive_access(node):
                    used_frames.add(i)
                    break  # 早停机制
                    
        cand[node.id] = hits
    return cand
```

#### **阶段4: 条件检查策略**

**4.1 Escalate策略升级流程**:

```yaml
escalation_order: [text, regex, ui, action, dynamic_match, ocr, llm]
```

**4.2 Dynamic Match动态条件检查**:

```python
# 从任务描述提取条件
if "价格最低" in task_description:
    # 在推理文本中验证是否执行了价格排序
    verify_in_reasoning("价格", "低到高", "便宜")
```

**4.3 OCR多模态处理**:

```python
def frame_ocr(frame):
    # 1. 优先使用OCR识别图片
    if image_exists:
        text = ocr_engine.recognize(image_path)
        if text: return processed_text
    
    # 2. 降级到XML文本提取
    xml_text = extract_text_from_xml(xml_content)
    return xml_text
```

#### **阶段5: 动态规划求解**

```python
def verify(frames, task, options):
    # 1. 收集候选帧
    candidates = _collect_candidates(frames, task, options)
    
    # 2. DP计算最小可行索引
    min_idx = {}
    for node_id in topo_order:
        deps = get_dependencies(node_id)
        
        # 依赖约束：必须晚于所有依赖节点
        min_required = max(min_idx[dep] for dep in deps) if deps else 0
        
        # 找到第一个满足顺序约束的候选帧
        feasible = _min_feasible_index(candidates[node_id], min_required)
        min_idx[node_id] = feasible
    
    # 3. 检查成功条件
    success_satisfied = check_success_condition(min_idx, task.success)
    
    # 4. 路径回溯
    if success_satisfied:
        path = backtrack_optimal_path(min_idx, task.success)
        return VerifyResult(ok=True, matched=path)
    else:
        return VerifyResult(ok=False, manual_review_needed=True)
```

#### **阶段6: 结果生成与路径回溯**

```python
# 1. 成功路径回溯
if task.success.any_of:
    # 选择最早完成的成功节点
    target = min(success_nodes, key=lambda n: min_idx[n])
    path = backtrack(target)
    
elif task.success.all_of:
    # 回溯所有必需节点的路径
    paths = [backtrack(node) for node in success_nodes]
    path = merge_unique_paths(paths)

# 2. 构建验证结果
return VerifyResult(
    ok=True,
    matched=[NodeMatch(node_id=nid, frame_index=idx) for idx, nid in path],
    logs=decision_logs,
    manual_review_needed=False
)
```

###  **关键创新特性**

#### 1. **智能帧管理机制**

- **帧独占模式**: OCR/LLM验证时避免帧重复使用
- **防回退机制**: 线性流程中防止回退到已使用的帧
- **早停优化**: 找到匹配后立即停止，提高效率

#### 2. **多模态验证能力**

- **OCR集成**: 支持PaddleOCR和Tesseract双引擎
- **LLM推理**: 结合截图和上下文的多模态验证
- **降级策略**: OCR失败时自动降级到XML文本提取

#### 3. **动态条件匹配**

- **任务感知**: 从任务描述自动提取验证条件
- **模式映射**: 支持复杂的条件模式配置
- **灵活验证**: 在多个字段中查找验证关键词

#### 4. **策略升级机制**

- **渐进式验证**: 从简单到复杂的多层级检查
- **智能降级**: 高级策略失败时自动降级
- **配置驱动**: 支持自定义升级顺序

### 📊 **验证结果示例**

```python
VerifyResult(
    ok=True,  # 验证成功
    matched=[
        NodeMatch(node_id="open_app_home", frame_index=0),
        NodeMatch(node_id="activate_search", frame_index=1), 
        NodeMatch(node_id="input_keyword", frame_index=2),
        NodeMatch(node_id="submit_search", frame_index=3),
        NodeMatch(node_id="apply_filter_condition", frame_index=4),
        NodeMatch(node_id="add_to_cart", frame_index=6)
    ],
    logs=[...],  # 详细决策日志
    manual_review_needed=False  # 无需人工复核
)
```

### 🔧 **扩展能力**

#### 1. **自定义检查器**

```python
@register_condition("custom_checker")
class CustomChecker(ConditionChecker):
    def check(self, frame, params, options):
        # 自定义验证逻辑
        return custom_logic(frame, params)
```

#### 2. **配置驱动的任务定义**

- 支持复杂的依赖关系定义
- 灵活的成功条件配置
- 可扩展的条件参数

#### 3. **多种数据源支持**

- 目录结构的复杂轨迹
- 自定义数据格式扩展

这个框架特别适合验证包含复杂筛选条件app操作任务场景，能够智能地从任务描述中提取条件并验证是否正确执行了相应操作。
